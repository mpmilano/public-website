[{"authors":["Matthew P. Milano","Andrew C. Myers"],"categories":null,"content":"","date":1542862800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543344400,"objectID":"113968a6643b66a7aebfd94f7f07cfc2","permalink":"http://www.cs.cornell.edu/~milano/publication/mixt-tr/","publishdate":"2018-11-22T00:00:00-05:00","relpermalink":"/~milano/publication/mixt-tr/","section":"publication","summary":"","tags":null,"title":"A Language for Mixing Consistency in Geodistributed Transactions: Technical Report","type":"publication"},{"authors":["Matthew Milano"],"categories":null,"content":"Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1529467200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543340931,"objectID":"dd5bf8297dc4140f7f926f1a0e9582cd","permalink":"http://www.cs.cornell.edu/~milano/talk/mixt/","publishdate":"2018-06-20T00:00:00-04:00","relpermalink":"/~milano/talk/mixt/","section":"talk","summary":"Programming concurrent, distributed systems is hardM-bM-^@M-^Tespecially when these systems mutate shared, persistent state replicated at geographic scale. To enable high availability and scalability, a new class of weakly consistent data stores has become popular. However, some data needs strong consistency. To manipulate both weakly and strongly consistent data in a single transaction, we introduce a new abstraction: mixed-consistency transactions, embodied in a new embedded language, MixT. Programmers explicitly associate consistency models with remote storage sites; each atomic, isolated transaction can access a mixture of data with different consistency models. Compile-time information-flow checking, applied to consistency models, ensures that these models are mixed safely and enables the compiler to automatically partition transactions into a single sub-transaction per consistency model. New run-time mechanisms ensure that consistency models can also be mixed safely, even when the data used by a transaction resides on separate, mutually unaware stores. Performance measurements show that despite their stronger guarantees, mixed-consistency transactions retain much of the speed of weak consistency, significantly outperforming traditional serializable transactions.","tags":[],"title":"MixT talk","type":"talk"},{"authors":["Matthew Milano"],"categories":null,"content":" It\u0026rsquo;s been a long wait. It was our great pleasure to present the MixT paper at this year\u0026rsquo;s PLDI, but we always felt that the conference version was missing a few details and extra explanations which (we sincerely hope) would go a long way towards explaining the MixT approach to distributed transactions. So it makes us overjoyed to finally make the extended Technical Report of the MixT paper available to the public.\nSo what\u0026rsquo;s this MixT thing all about, anyway? MixT is a domain-specific programming language for writing transactions, embedded into C++. What makes MixT unique is its approach to consistency and transaction isolation: rather than associate consistency with operations, MixT associates consistency with data and expects programmers to use multiple consistency models in the same application. With MixT:\n Transactions compile down to a sequence of standard, single-consistency transactions appropriate for execution on any number of SQL/NoSQL/NewSQL datastores.\n An information-flow type system keeps your consistent data safe from corruption by less-consistent data.\n You can use multiple consistency models even within a single transaction.\n A single transaction can execute across multiple independent datastores, while still preserving write atomicity.\n Transactions are expressive; you can define custom operations as methods, use while-loops and if-statements, and generally write code that looks and feels like the surrounding C++.\n   But the best explanation is the paper. What\u0026rsquo;s new for the TR? The technical report contains many details not previously seen in the MixT paper! You can expect to see extended rules for typing and translation, an all-new section featuring correctness arguments and read witnesses, and a loose formalization of how to lift isolation levels (in the database sense) to distributed consistency models. And more!\nYou can find it here Happy reading!\n","date":1529467200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543340931,"objectID":"bedf3a24af564145ec1cd29436a018e2","permalink":"http://www.cs.cornell.edu/~milano/post/mixt-tr/","publishdate":"2018-06-20T00:00:00-04:00","relpermalink":"/~milano/post/mixt-tr/","section":"post","summary":"Presenting MixT, our language for sanely mixing distinct consistency levels within a single transaction. Now in Tech Report form!","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Mixing Consistency with MixT: Technical Report Available!","type":"post"},{"authors":null,"categories":null,"content":" Concurrency makes everything hard For many programmers, writing efficient concurrent datastructures is an exercise in scouring github and hoping that code quality and number of \u0026ldquo;stars\u0026rdquo; really do correlate. When it comes time to write your own concurrent datastructures, queue many sleepless nights spent worrying about whether this or that particular concurrency primitive is fast enough, or correct enough, to make the code work at the speeds you need. If there is any solace felt, it comes from the once-safe assumption of strong consistency; that, no matter how many races we might have missed, at least the result of the program will be some valid interleaving of concurrent threads.\nThis assumption is wrong. Because hardware isn\u0026rsquo;t as helpful as it once was. Modern processor and language memory models reduce the available consistency assumptions so much that it\u0026rsquo;s possible to read values which were never written, justify your own reads, and arbitrarily miss updates from concurrent threads. Simple patterns, like initializing an object and then handing it off directly to a newly-spawned thread, are simply not guaranteed to work.\nAnd distribution makes it harder. In a distributed setting, the costs of using stronger consistency models grow exponentially with the number of replicas in your system (essential for fault-tolerance) and the distance between these replicas (essential for global performance and availability). While there are a lot of good people doing excellent work to try and bring strongly-consistent shared data to a geo-distributed setting, the fundamentals are still not in our favor. And, far more urgently, major parts of the web have already moved to weaker consistency models.\nWe\u0026rsquo;re going to fix that. Or at least help. This project aims to bring the power of programming languages to bear on the world of weakly-consistent distributed programming. Our secret sauce is information flow, a key technology borrowed from the security literature and applied with new life here. Using information flow, it\u0026rsquo;s possible to ensure that weakly-consistent observations can never unduly influence strongly-consistent computations; it makes the points of crossover explicit, statically requiring that programmers upgrade the consistency of their observations when appropriate.\nThis technique is powerful; for more details, see our paper from PLDI 2018.\nAnd we\u0026rsquo;re not done yet. There are a lot of excellent ideas out there that have their own ways of ensuring weak consistency doesn\u0026rsquo;t mean weak guarantees; everything from data types with guaranteed convergence, to techniques for guaranteeing only what computations need, and a whole host in-between. We believe that there are many unrealized synergies between our established information-flow approach and these robust alternate methods. We\u0026rsquo;re taking advantage of these synergies to build a new language for programming distributed systems.\nScoped strong semantic consistency is the goal. This property comes under a lot of different names; you may have heard it as strong eventual consistency, or convergence, or full-program commutativity to name just a few. Simply stated, this is the property that all observable effects generated by your program under weakly-consistent, asynchronous replication\u0026mdash;any way in which it interacts with the outside world\u0026mdash;would still be generated under a perfectly-consistent, sequential execution (given the same environment and inputs). It says that every witness to weakly-consistent replication, every race condition, every speculative execution is in fact justified; we have, somehow, always \u0026ldquo;guessed\u0026rdquo; right. This property is exceptionally strong (in fact, it\u0026rsquo;s likely too strong), but it makes a noble goal; we want to empower programmers with the guarantee that their entire program will be consistent by default, while providing them the flexibility to break these guarantees with clear-eyed intention; and we want to preserve these guarantees across the great majority of the program even in the presence of small intentional violations. A new programming paradigm is coming, as fast as we can write it down. Watch this space!\n","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543341466,"objectID":"9abcd3af79b104f0646fbc4376cf518d","permalink":"http://www.cs.cornell.edu/~milano/project/languages-for-distribution/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/~milano/project/languages-for-distribution/","section":"project","summary":"Distributed Languages frequently either fail to capture replication, or insist in high-latency lockstep state machine replication.  Storage systems which avoid both pitfalls often do so by weakening consistency. We try to reign in weak consistency and capture replication and concurrency, all while constructively avoiding races and allowing safe, loosely-synchronized replication.","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Programming Replicated, Distributed Systems","type":"project"},{"authors":["Matthew Milano","Andrew C. Myers"],"categories":null,"content":"","date":1527825600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543340931,"objectID":"70c8ea9b0a628d469a99e2d3819fa718","permalink":"http://www.cs.cornell.edu/~milano/publication/mixt/","publishdate":"2018-06-01T00:00:00-04:00","relpermalink":"/~milano/publication/mixt/","section":"publication","summary":"","tags":null,"title":"MixT: A Language for Mixing Consistency in Geodistributed Transactions","type":"publication"},{"authors":["Sagar Jha","Jonathan Behrens","Theo Gkountouvas","Matthew Milano","Weijia Song","Edward Tremel","Sydney Zink","Kenneth P. Birman","Robbert Van Renesse"],"categories":null,"content":"","date":1509508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543340931,"objectID":"3e62bf437b39d8b2fd35b76d913cfc66","permalink":"http://www.cs.cornell.edu/~milano/publication/derecho-tr/","publishdate":"2017-11-01T00:00:00-04:00","relpermalink":"/~milano/publication/derecho-tr/","section":"publication","summary":"The coming generation of Internet-of-Things (IoT) applications will process massive amounts of incoming data while supporting data mining and online learning. In cases with demanding real-time requirements, such systems behave as smart memories: high-bandwidth services that capture sensor input, proceses it using machine-learning tools, replicate and store “interesting” data (discarding uninteresting content), update knowledge models, and trigger urgently-needed responses. Derecho is a high-throughput librry for building smart memories and similar services. At its core Derecho implements atomic multicast and state machine replication. Derecho’s replicated template defines a replicated type; the corresponding objects are associated with subgroups, which can be sharded into keyvalue structures. The persistent and volatile storage templates implement version vectors with optional NVM persistence. These support time-indexed access, offering lock-free snapshot isolation that blends temporal precision and causal consistency. Derecho automates application management, supporting multigroup structures and providing consistent knowledge of the current membership mapping. A query can access data from many shards or subgroups, and consistency is guaranteed without any form of distributed locking. Whereas many systems run consensus on the critical path, Derecho requires consensus only when updating membership. By leveraging an RDMA data plane and NVM storage, and adopting a novel receiver-side batching technique, Derecho can saturate a 12.5GB RDMA network, sending millions of events per second in each subgroup or shard. In a single subgroup with 2-16 members, throughput peaks at 16 GB/s for large (100MB or more) objects. When using version-vector storage, Derecho is limited by the speed of the SSD or RamDisk, showing no loss of performance as group sizes grow. While key-value subgroups would typically use 2 or 3-member shards, unsharded subgroups could be large. In tests with a 128-member group, Derecho’s multicast and Paxos protocols were just 2-3x slower than for a small group, depending on the traffic pattern. With network contention, slow members, or overlapping groups that generate concurrent traffic, Derecho’s protocols remain stable and adapt to the available bandwidth.","tags":null,"title":"Building Smart Memories and Cloud Services with Derecho","type":"publication"},{"authors":["Matthew P. Milano","Andrew C. Myers"],"categories":null,"content":"","date":1475294400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543344400,"objectID":"2f7527a392ce159e01ff4f958f69e4ce","permalink":"http://www.cs.cornell.edu/~milano/publication/mm-16-tr/","publishdate":"2016-10-01T00:00:00-04:00","relpermalink":"/~milano/publication/mm-16-tr/","section":"publication","summary":"","tags":null,"title":"Mixing Consistency in Geodistributed Transactions: Technical Report (old)","type":"publication"},{"authors":["Nate Foster","Dexter Kozen","Matthew Milano","Alexandra Silva","Laure Thompson"],"categories":null,"content":"","date":1435723200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542994807,"objectID":"87bc941cff91d9e6bcea323d33b3d12a","permalink":"http://www.cs.cornell.edu/~milano/publication/netkat/","publishdate":"2015-07-01T00:00:00-04:00","relpermalink":"/~milano/publication/netkat/","section":"publication","summary":"","tags":null,"title":"A Coalgebraic Decision Procedure for NetKAT","type":"publication"},{"authors":null,"categories":null,"content":" In-datacenter replication just got a lot faster. Derecho is a new framework for building replicated, fault-tolerant distributed systems within a datacenter. At its core, Derecho provides a best-in-class consistent multicast abstraction, sending multi-target messages at blazing speed and in lock-step. Derecho\u0026rsquo;s object-oriented programming layer makes it easy to build any distributed application straight from a standard, single-machine approach; individual classes are automatically replicated in user-specified configurations, and a straightforward, type-safe RPC mechanism allows easy communication between replica groups.\nDerecho realizes a major observation: that programming a distributed system with an eye towards protocol convergence (or strong eventual consistency) yields significant performance benefits by delaying consensus events for as long as possible. Derecho\u0026rsquo;s core protocols are written in a simple convergent programming language (watch this space), giving us constructive confidence that our protocols never diverge \u0026ndash; which avoids much of the proof (and correctness) burden of traditional distributed system design.\nThis project is a major collaboration between several groups at Cornell University; the group is expanding every day, but has so far included Sagar Jha, Jonathan Behrens, Theo Gkountouvas, Matthew Milano, Weijia Song, Edward Tremel, Sydney Zink, Kenneth P. Birman, Robbert Van Renesse, and the students of CS4999. For more detail, you should check the project website or read about it on Ken Birman\u0026rsquo;s blog.\n","date":1433116800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543340931,"objectID":"c8c99074cdb6b42a7de679e50da0c1b4","permalink":"http://www.cs.cornell.edu/~milano/project/derecho/","publishdate":"2015-06-01T00:00:00Z","relpermalink":"/~milano/project/derecho/","section":"project","summary":"Avoiding communication while building a high-throughput, RDMA-based distributed framework for replicated systems","tags":["Transactions","Consistency","Programming Languages","Distributed Systems"],"title":"Derecho: Programming the Datacenter","type":"project"},{"authors":["Joe Gibbs Politz","Alejandro Martinez","Matthew Milano","Sumner Warren","Daniel Patterson","Junsong Li","Anand Chitipothu","Shriram Krishnamurthi"],"categories":null,"content":"","date":1357016400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542994807,"objectID":"46a2253e7e38a5df8328b38638d550e6","permalink":"http://www.cs.cornell.edu/~milano/publication/python/","publishdate":"2013-01-01T00:00:00-05:00","relpermalink":"/~milano/publication/python/","section":"publication","summary":"","tags":null,"title":"Python: The Full Monty","type":"publication"}]